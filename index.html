<div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res = []
        i = 0
        
        while i < len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            i = j + 1
            j = i + length
            res.append(s[i:j])
            i = j
            
        return res</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "LENGTH PREFIX",
            mnemonicsContent: `
              <ul>
                <li><strong>Length + Delimiter:</strong> Encode using format "length#string".</li>
                <li><strong>Two-Pointer Extraction:</strong> Use two pointers to parse the encoded string.</li>
                <li><strong>Find-Parse-Extract:</strong> Find the delimiter, parse the length, extract the substring.</li>
                <li><strong>Sequential Reading:</strong> Decode by reading one string at a time, moving forward.</li>
                <li><strong>Think Network Protocols:</strong> This encoding is similar to how data is transmitted in networks.</li>
              </ul>
            `
          },
          {
            id: 7,
            title: "Product of Array Except Self",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Product of Array Except Self</div>
              <p>Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].</p>
              <p>Each product is guaranteed to fit in a 32-bit integer.</p>
              <p>Follow-up: Could you solve it in O(n) time without using the division operation?</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [1,2,4,6]
Output: [48,24,12,8]</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Product of Array Except Self</div>
              <ul>
                <li>Consider the product of all numbers to the left of each index</li>
                <li>Consider the product of all numbers to the right of each index</li>
                <li>Can you use prefix and suffix products?</li>
                <li>How can you avoid using extra space?</li>
                <li>Try using the output array to store intermediate results</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create a result array filled with 1s (same size as input)
2. Calculate prefix products:
   a. Initialize a variable to track the running product = 1
   b. Iterate from left to right
   c. Store the current prefix product in the result array
   d. Update the running product by multiplying with the current input value
3. Calculate suffix products and multiply with prefix products:
   a. Initialize a variable to track the running product = 1
   b. Iterate from right to left
   c. Multiply the current result value by the suffix product
   d. Update the running product by multiplying with the current input value
4. Return the result array</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            method: "PREFIX & SUFFIX",
            mnemonicsContent: `
              <ul>
                <li><strong>Two-Pass Approach:</strong> First calculate prefix products, then suffix products.</li>
                <li><strong>Running Product:</strong> Maintain a running product as you iterate through the array.</li>
                <li><strong>Output Array Reuse:</strong> Use the output array to store intermediate results (prefix products).</li>
                <li><strong>Multiplication Splitting:</strong> The product of all except self = (product of all before) * (product of all after).</li>
                <li><strong>No Division Needed:</strong> Solve without using division by splitting the calculation.</li>
              </ul>
            `
          },
          {
            id: 8,
            title: "Valid Sudoku",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Valid Sudoku</div>
              <p>You are given a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:</p>
              <ul>
                <li>Each row must contain the digits 1-9 without duplicates.</li>
                <li>Each column must contain the digits 1-9 without duplicates.</li>
                <li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.</li>
              </ul>
              <p>Return true if the Sudoku board is valid, otherwise return false.</p>
              <p>Note: A board does not need to be full or be solvable to be valid.</p>
              <br>
              <pre>
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Valid Sudoku</div>
              <ul>
                <li>Consider checking rows, columns, and 3x3 boxes separately</li>
                <li>How can you detect if a number appears more than once?</li>
                <li>Think about using sets to track seen numbers</li>
                <li>What's an efficient way to map a cell to its 3x3 box?</li>
                <li>Remember to skip empty cells ('.')</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Check each row:
   a. For each row, create a set to track seen digits
   b. Iterate through each cell in the row
   c. Skip empty cells
   d. If a digit is already in the set, return False
   e. Otherwise, add the digit to the set
2. Check each column (similar to rows)
3. Check each 3x3 box:
   a. For each of the 9 boxes, create a set
   b. Map each cell to its corresponding box
   c. Skip empty cells
   d. Check for duplicates using the set
4. If all checks pass, return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n²)</span>
                <span class="complexity space">Space: O(n²)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in range(9):
            seen = set()
            for i in range(9):
                if board[row][i] == ".": 
                    continue
                if board[row][i] in seen:
                    return False
                seen.add(board[row][i])
        
        for col in range(9):
            seen = set()
            for i in range(9):
                if board[i][col] == ".":
                    continue
                if board[i][col] in seen:
                    return False
                seen.add(board[i][col])
            
        for square in range(9):
            seen = set()
            for i in range(3):
                for j in range(3):
                    row = (square//3) * 3 + i
                    col = (square % 3) * 3 + j
                    if board[row][col] == ".":
                        continue
                    if board[row][col] in seen:
                        return False
                    seen.add(board[row][col])
        return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n²)</span>
                <span class="complexity space">Space: O(n²)</span>
              </div>
            `,
            method: "HASH SET",
            mnemonicsContent: `
              <ul>
                <li><strong>Three Separate Checks:</strong> Validate rows, columns, and 3x3 boxes independently.</li>
                <li><strong>Set-Based Validation:</strong> Use hash sets to detect duplicates in each group.</li>
                <li><strong>Box Indexing Formula:</strong> (square//3)*3 + i for row, (square%3)*3 + j for column.</li>
                <li><strong>Empty Cell Skipping:</strong> Always skip cells containing "." before checking.</li>
                <li><strong>Early Return:</strong> As soon as any invalid condition is found, return False.</li>
              </ul>
            `
          },
          {
            id: 9,
            title: "Longest Consecutive Sequence",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Longest Consecutive Sequence</div>
              <p>Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.</p>
              <p>A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.</p>
              <p>You must write an algorithm that runs in O(n) time.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [2,20,4,10,3,4,5]
Output: 4</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Longest Consecutive Sequence</div>
              <ul>
                <li>How can you efficiently find if a number is part of a sequence?</li>
                <li>Consider using a set for O(1) lookups</li>
                <li>When should you start counting a sequence?</li>
                <li>Is there a way to avoid duplicate work?</li>
                <li>Think about finding the start of each sequence</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create a set from the input array for O(1) lookups
2. Initialize a variable to track the longest sequence found
3. For each number in the set:
   a. Check if it's the start of a sequence (num-1 is not in the set)
   b. If it's a start, count consecutive numbers (num+1, num+2, etc.)
   c. Update the longest sequence if the current one is longer
4. Return the length of the longest sequence found</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "HASH SET",
            mnemonicsContent: `
              <ul>
                <li><strong>Find Sequence Starts:</strong> Only check numbers that could be the start of a sequence.</li>
                <li><strong>Efficient Lookups:</strong> Use a hash set for O(1) membership tests.</li>
                <li><strong>Linear Scanning:</strong> Once a start is found, iterate forward to find sequence length.</li>
                <li><strong>Avoid Duplicate Work:</strong> Skip numbers that can't be sequence starts.</li>
                <li><strong>Track Max Length:</strong> Keep track of the longest sequence found so far.</li>
              </ul>
            `
          },
          {
            id: 10,
            title: "Valid Palindrome",
            category: "Two Pointers",
            questionContent: `
              <div class="card-title">Valid Palindrome</div>
              <p>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.</p>
              <p>Given a string s, return true if it is a palindrome, otherwise return false.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Valid Palindrome</div>
              <ul>
                <li>How do you handle uppercase and lowercase characters?</li>
                <li>What characters should you ignore?</li>
                <li>Can you use two pointers to check from both ends?</li>
                <li>Consider how to efficiently compare characters without creating a new string</li>
                <li>What are the edge cases to handle?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Initialize two pointers, left at the beginning and right at the end
2. While left < right:
   a. Skip non-alphanumeric characters from left
   b. Skip non-alphanumeric characters from right
   c. Compare characters at left and right (case-insensitive)
   d. If they don't match, return False
   e. Move left forward and right backward
3. If the loop completes, return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def isPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1
        
        while l < r:
            while l < r and not self.isAlphaNum(s[l]):
                l += 1
            while l < r and not self.isAlphaNum(s[r]):
                r -= 1
                
            if s[l].lower() != s[r].lower():
                return False
                
            l += 1
            r -= 1
        return True
    
    def isAlphaNum(self, c: str) -> bool:
        return (ord('A') <= ord(c) <= ord('Z') or
                ord('a') <= ord(c) <= ord('z') or
                ord('0') <= ord(c) <= ord('9'))</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            method: "TWO POINTERS",
            mnemonicsContent: `
              <ul>
                <li><strong>Skip and Compare:</strong> Skip irrelevant characters, compare valid ones.</li>
                <li><strong>Outside-In Approach:</strong> Check from both ends moving inward.</li>
                <li><strong>Case Insensitivity:</strong> Convert to lowercase before comparing.</li>
                <li><strong>In-place Checking:</strong> No need for extra string - check the original directly.</li>
                <li><strong>Helper Function:</strong> Create a separate function for character validation to keep code clean.</li>
              </ul>
            `
          }
        ];

        // Debug message
        console.log("Cards data loaded successfully with " + cardsData.length + " cards");
    </script>
    
    <script>
        // Global variable to track current card
        let currentCardIndex = 0;
        
        // Function to update the card content
        function updateCardContent() {
            console.log("Updating card to index:", currentCardIndex);
            console.log("Total cards:", cardsData.length);
            
            // Make sure cardsData is available
            if (!cardsData || !cardsData.length) {
                console.error("Card data not found!");
                return;
            }
            
            const card = cardsData[currentCardIndex];
            console.log("Current card:", card.title);
            
            // Update category badge
            document.getElementById('category-badge').textContent = card.category || "Unknown";
            
            // Update tab contents
            document.getElementById('question').innerHTML = card.questionContent || "Question content missing";
            document.getElementById('hint').innerHTML = card.hintContent || "Hint content missing";
            document.getElementById('blueprint').innerHTML = card.blueprintContent || "Blueprint content missing";
            document.getElementById('code').innerHTML = card.codeContent || "Code content missing";
            
            // Update back side
            document.getElementById('method-badge').textContent = card.method || "METHOD";
            document.getElementById('mnemonics').innerHTML = card.mnemonicsContent || "Mnemonics content missing";
            
            // Update navigation
            document.getElementById('current-card').textContent = currentCardIndex + 1;
            document.getElementById('total-cards').textContent = cardsData.length;
            
            // Update navigation buttons
            document.getElementById('prev-button').disabled = currentCardIndex === 0;
            document.getElementById('next-button').disabled = currentCardIndex === cardsData.length - 1;
        }
        
        // Card flip functionality
        document.querySelector('.flashcard').addEventListener('click', function(e) {
            // Don't flip if clicking on tabs
            if (!e.target.classList.contains('tab')) {
                this.classList.toggle('is-flipped');
            }
        });
        
        // Tab switching functionality
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip when clicking on tabs
                
                // Remove active class from all tabs and tab contents
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab
                this.classList.add('active');
                
                // Show corresponding tab content
                const tabId = this.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });
        
        // Navigation buttons
        document.getElementById('prev-button').addEventListener('click', function() {
            console.log("Prev button clicked, current index:", currentCardIndex);
            if (currentCardIndex > 0) {
                currentCardIndex--;
                updateCardContent();
                // Ensure card is showing front side when navigating
                document.querySelector('.flashcard').classList.remove('is-flipped');
            }
        });
        
        document.getElementById('next-button').addEventListener('click', function() {
            console.log("Next button clicked, current index:", currentCardIndex);
            if (currentCardIndex < cardsData.length - 1) {
                currentCardIndex++;
                updateCardContent();
                // Ensure card is showing front side when navigating
                document.querySelector('.flashcard').classList.remove('is-flipped');
            }
        });
        
        // Theme switching functionality
        const themeButtons = document.querySelectorAll('.theme-btn');
        themeButtons.forEach(button => {
            button.addEventListener('click', function() {
                const body = document.body;
                
                // Remove all theme classes
                body.classList.remove('light-theme', 'dark-theme', 'blue-theme');
                
                // Add selected theme class
                if (this.classList.contains('light-btn')) {
                    body.classList.add('light-theme');
                } else if (this.classList.contains('dark-btn')) {
                    body.classList.add('dark-theme');
                } else if (this.classList.contains('blue-btn')) {
                    body.classList.add('blue-theme');
                }
            });
        });
        
        // Initialize the app as soon as possible
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing cards");
            updateCardContent();
        });

        // Also try to initialize immediately
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            console.log("Document already loaded, initializing now");
            setTimeout(updateCardContent, 100);
        }

        // Initialize immediately regardless of document state
        updateCardContent();
    </script>
</body>
</html>
