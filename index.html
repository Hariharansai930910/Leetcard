<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode Flashcards</title>
    <style>
        /* Global styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }

        body {
            background-color: #f5f5f5;
            padding: 20px;
            transition: background-color 0.3s ease;
        }

        /* Theme colors */
        body.light-theme {
            background-color: #f5f5f5;
            color: #333;
        }

        body.dark-theme {
            background-color: #1e1e1e;
            color: #f5f5f5;
        }

        body.blue-theme {
            background-color: #e6f7ff;
            color: #0a3055;
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            margin-bottom: 30px;
            position: relative;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
        }

        /* Score display */
        .score-container {
            position: absolute;
            top: 0;
            right: 100px;
            z-index: 100;
        }

        #score-display {
            background-color: #4a90e2;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        #score-display.high-score {
            background-color: #ffd700;
            color: #333;
            transform: scale(1.05);
        }

        /* Animation for points gained */
        .points-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 3rem;
            font-weight: bold;
            opacity: 0;
            z-index: 1000;
            text-shadow: 0 0 10px rgba(255,215,0,0.5);
        }

        .points-animation.animate {
            animation: points-popup 1s ease-out forwards;
        }

        @keyframes points-popup {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -30%) scale(1);
            }
        }

        /* Theme selector */
        .theme-selector {
            display: flex;
            gap: 10px;
        }

        .theme-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ccc;
            transition: transform 0.2s;
        }

        .theme-btn:hover {
            transform: scale(1.1);
        }

        .light-btn {
            background-color: #f5f5f5;
        }

        .dark-btn {
            background-color: #1e1e1e;
        }

        .blue-btn {
            background-color: #e6f7ff;
        }

        /* Navigation controls */
        .card-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            align-items: center;
        }

        .nav-button {
            background-color: #4a90e2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .nav-button:hover {
            background-color: #357abd;
        }

        .nav-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .card-counter {
            margin: 0 15px;
            font-weight: bold;
        }

        /* Flashcard container */
        .flashcard-container {
            perspective: 1000px;
            width: 500px;
            height: 500px;
            margin: 0 auto;
            position: relative;
            aspect-ratio: 1/1;
        }

        /* Flashcard */
        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border-radius: 10px;
        }

        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }

        /* Card sides */
        .card-side {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            overflow: hidden;
            border-radius: 10px;
        }

        .card-front {
            background-color: white;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        .card-back {
            background-color: #ffd700;
            color: #333;
            transform: rotateY(180deg);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        /* Scrollable content */
        .content-scrollable {
            overflow-y: auto;
            padding: 20px;
            flex-grow: 1;
            max-height: 100%;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background-color: #f0f0f0;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }

        .tab {
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
            flex-grow: 1;
            text-align: center;
            font-weight: bold;
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            background-color: white;
            border-bottom: 3px solid #ffd700;
        }

        /* Tab content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Code styling */
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }

        /* Code block styling */
        .code-block {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 200px;
            margin-bottom: 15px;
        }

        /* Custom scrollbar for code blocks */
        .code-block::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .code-block::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .code-block::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .code-block::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Dark theme scrollbar */
        body.dark-theme .code-block::-webkit-scrollbar-track {
            background: #333;
        }

        body.dark-theme .code-block::-webkit-scrollbar-thumb {
            background: #666;
        }

        /* Explanation and mnemonics styling */
        .explanation-block {
            background-color: rgba(0, 0, 0, 0.05);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .mnemonics-block {
            background-color: rgba(255, 215, 0, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 4px solid #ffd700;
        }

        body.dark-theme .explanation-block {
            background-color: rgba(255, 255, 255, 0.05);
        }

        body.dark-theme .mnemonics-block {
            background-color: rgba(255, 215, 0, 0.2);
        }

        body.blue-theme .explanation-block {
            background-color: rgba(0, 120, 215, 0.05);
        }

        body.blue-theme .mnemonics-block {
            background-color: rgba(0, 120, 215, 0.1);
            border-left: 4px solid #0078d7;
        }

        /* Dark theme overrides */
        body.dark-theme .card-front {
            background-color: #2d2d2d;
            color: #f5f5f5;
        }

        body.dark-theme .tabs {
            background-color: #3d3d3d;
        }

        body.dark-theme .tab.active {
            background-color: #2d2d2d;
        }

        body.dark-theme pre {
            background-color: #3d3d3d;
            color: #f5f5f5;
        }

        body.dark-theme .code-block {
            background-color: #3d3d3d;
            color: #f5f5f5;
        }

        /* Blue theme overrides */
        body.blue-theme .card-front {
            background-color: #f0f8ff;
            color: #0a3055;
        }

        body.blue-theme .tabs {
            background-color: #d6eaff;
        }

        body.blue-theme .tab.active {
            background-color: #f0f8ff;
            border-bottom: 3px solid #0078d7;
        }

        body.blue-theme .card-back {
            background-color: #b3e0ff;
            color: #0a3055;
        }

        body.blue-theme pre {
            background-color: #e6f7ff;
            color: #0a3055;
        }

        body.blue-theme .code-block {
            background-color: #e6f7ff;
            color: #0a3055;
        }

        /* Card title */
        .card-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Complexity badges */
        .complexity {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 8px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .time {
            background-color: #e6f7ff;
            color: #0078d7;
        }

        .space {
            background-color: #fff4e6;
            color: #ff9500;
        }

        /* Dark theme complexity badges */
        body.dark-theme .complexity.time {
            background-color: #003366;
            color: #4db8ff;
        }

        body.dark-theme .complexity.space {
            background-color: #663300;
            color: #ffc266;
        }

        /* Method badge */
        .method-badge {
            display: inline-block;
            padding: 5px 10px;
            background-color: #ffd700;
            color: #333;
            border-radius: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        body.dark-theme .method-badge {
            background-color: #ffd700;
            color: #333;
        }

        body.blue-theme .method-badge {
            background-color: #0078d7;
            color: white;
        }

        /* Category badge */
        .category-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: #4a90e2;
            color: white;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
        }

        body.dark-theme .category-badge {
            background-color: #357abd;
        }

        body.blue-theme .category-badge {
            background-color: #0069be;
            color: white;
        }

        /* Share button */
        .share-button {
            position: absolute;
            top: 10px;
            right: 80px;
            width: 32px;
            height: 32px;
            background-color: #4a90e2;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            transition: background-color 0.2s;
        }

        .share-button:hover {
            background-color: #357abd;
        }

        body.dark-theme .share-button {
            background-color: #357abd;
        }

        body.blue-theme .share-button {
            background-color: #0069be;
        }

        .share-tooltip {
            position: absolute;
            background-color: white;
            color: #333;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            top: 45px;
            right: 0;
            width: 200px;
            display: none;
            z-index: 11;
        }

        .share-tooltip.active {
            display: block;
        }

        body.dark-theme .share-tooltip {
            background-color: #2d2d2d;
            color: white;
        }

        body.blue-theme .share-tooltip {
            background-color: #f0f8ff;
            color: #0a3055;
        }

        .copy-button {
            background-color: #4a90e2;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
            font-size: 0.9em;
        }

        .copy-button:hover {
            background-color: #357abd;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px 0;
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body class="light-theme">
    <div class="container">
        <header>
            <div class="logo">LeetCode Flashcards</div>
            <div class="score-container">
                <div id="score-display">Weekly Score: 0</div>
            </div>
            <div class="theme-selector">
                <div class="theme-btn light-btn" title="Light Theme"></div>
                <div class="theme-btn dark-btn" title="Dark Theme"></div>
                <div class="theme-btn blue-btn" title="Blue Theme"></div>
            </div>
        </header>

        <div class="card-navigation">
            <button class="nav-button" id="prev-button" disabled>Previous</button>
            <div class="card-counter">Card <span id="current-card">1</span> of <span id="total-cards">10</span></div>
            <button class="nav-button" id="next-button">Next</button>
        </div>

        <div class="flashcard-container">
            <div class="flashcard">
                <!-- Front side with tabs -->
                <div class="card-side card-front">
                    <div class="tabs">
                        <div class="tab active" data-tab="question">Question</div>
                        <div class="tab" data-tab="hint">Hint</div>
                        <div class="tab" data-tab="blueprint">Blueprint</div>
                        <div class="tab" data-tab="code">Code</div>
                    </div>
                    <div class="share-button" id="share-button" title="Share this card">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="18" cy="5" r="3"></circle>
                            <circle cx="6" cy="12" r="3"></circle>
                            <circle cx="18" cy="19" r="3"></circle>
                            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                        </svg>
                    </div>
                    <div class="category-badge" id="category-badge">Arrays & Hashing</div>
                    <div class="content-scrollable">
                        <!-- Dynamic content for tabs will be inserted here -->
                        <div class="tab-content active" id="question">Loading...</div>
                        <div class="tab-content" id="hint">Loading...</div>
                        <div class="tab-content" id="blueprint">Loading...</div>
                        <div class="tab-content" id="code">Loading...</div>
                    </div>
                </div>
                
                <!-- Back side with improved structure -->
                <div class="card-side card-back">
                    <span class="method-badge" id="method-badge">METHOD</span>
                    
                    <div class="content-scrollable">
                        <!-- Code explanation section -->
                        <div class="card-title">What This Code Does</div>
                        <div id="code-explanation" class="explanation-block">
                            Loading explanation...
                        </div>
                        
                        <!-- Mnemonics section -->
                        <div class="card-title">Memory Aids</div>
                        <div id="mnemonics" class="mnemonics-block">
                            Loading memory aids...
                        </div>
                        
                        <!-- Solution code -->
                        <div class="card-title">Solution Code</div>
                        <div class="code-block" id="solution-code">
                            Loading code...
                        </div>
                        
                        <!-- Quiz section -->
                        <button id="answer-button" class="nav-button" style="width: 100%; margin-top: 10px;">I Know The Answer (+10 points)</button>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>© 2025 LeetCode Flashcards | Click the card to flip</p>
        </footer>
    </div>

    <!-- IMPORTANT: Embedding card data directly in the HTML instead of loading from external file -->
    <script>
        // Arrays & Strings Flashcards Data - EMBEDDED DIRECTLY in the HTML
        const cardsData = [
          {
            id: 1,
            title: "Contains Duplicate",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Contains Duplicate</div>
              <p>Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [1, 2, 3, 3]
Output: true</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Contains Duplicate</div>
              <ul>
                <li>Think about how to efficiently check if you've seen a number before</li>
                <li>Could a hash set help with O(1) lookups?</li>
                <li>Consider the tradeoff between time and space complexity</li>
                <li>What's the brute force approach? How can we improve it?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create an empty hash set to track seen numbers
2. Iterate through each number in the array:
   a. Check if the current number is already in the set
   b. If it is, return True (found a duplicate)
   c. If not, add the number to the set
3. If we finish the loop without finding duplicates, return False</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "HASHSET",
            codeExplanation: "This code checks if a list of integers contains any duplicates. It iterates through the list, adding each number to a set. If a number is already in the set, it returns True (indicating a duplicate). If no duplicates are found, it returns False.",
            mnemonicsContent: `
              <ul>
                <li><strong>Club Entry Check:</strong> Like a bouncer at a club, the set (seen) is checking if anyone's already entered. Once seen, they're rejected!</li>
                <li><strong>Track As You Go:</strong> Add each element to a hash set as you encounter it.</li>
                <li><strong>Early Return:</strong> Return as soon as you find a duplicate - no need to process the entire array.</li>
                <li><strong>Set vs. Array:</strong> Sets provide O(1) lookup, which is crucial for efficiency here.</li>
                <li><strong>Think "Have I Seen This Before?":</strong> This pattern applies to many problems.</li>
              </ul>
            `
          },
          {
            id: 2,
            title: "Valid Anagram",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Valid Anagram</div>
              <p>Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.</p>
              <p>An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: s = "racecar", t = "carrace"
Output: true</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Valid Anagram</div>
              <ul>
                <li>What makes two strings anagrams of each other?</li>
                <li>Consider counting the frequency of each character</li>
                <li>Can you use a hash table or array to track character counts?</li>
                <li>What's an early termination condition?</li>
                <li>Are there any optimizations for lowercase English letters?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. If the strings have different lengths, they cannot be anagrams, return False
2. Create a frequency array of size 26 (for lowercase letters)
3. Iterate through both strings simultaneously:
   a. Increment the count for characters in the first string
   b. Decrement the count for characters in the second string
4. Check if all counts in the frequency array are zero
   a. If yes, the strings are anagrams, return True
   b. If any count is non-zero, return False</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n+m)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        count = [0] * 26
        for i in range(len(s)):
            count[ord(s[i]) - ord('a')] += 1
            count[ord(t[i]) - ord('a')] -= 1

        for val in count:
            if val != 0:
                return False
        return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n+m)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            method: "HASH TABLE",
            codeExplanation: "This code determines if two strings are anagrams (contain exactly the same characters in different order). First, it checks if the lengths match (if not, they can't be anagrams). Then it counts character frequencies using an array of 26 positions (for a-z). It increments counts for characters in the first string and decrements for the second. If the strings are anagrams, all counts will be zero.",
            mnemonicsContent: `
              <ul>
                <li><strong>Balance Sheet Approach:</strong> Think of each character as a financial transaction - deposits from string 1, withdrawals from string 2. At the end, all accounts should have zero balance!</li>
                <li><strong>Character Counting:</strong> Track the frequency of each character - anagrams have identical counts.</li>
                <li><strong>Array vs. Dictionary:</strong> For lowercase letters, a fixed-size array is more efficient than a hash map.</li>
                <li><strong>Plus-Minus Method:</strong> Increment for first string, decrement for second - at the end all should be zero.</li>
                <li><strong>Early Return on Length:</strong> Different lengths means not anagrams - check this first!</li>
              </ul>
            `
          },
          {
            id: 3,
            title: "Two Sum",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Two Sum</div>
              <p>Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.</p>
              <p>You may assume that every input has exactly one pair of indices i and j that satisfy the condition.</p>
              <p>Return the answer with the smaller index first.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [3,4,5,6], target = 7
Output: [0,1]</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Two Sum</div>
              <ul>
                <li>Consider what value you need to find for each number in the array</li>
                <li>Can you use a hash map to store values you've already seen?</li>
                <li>For each number, what is its complement to reach the target?</li>
                <li>Are there any edge cases to consider?</li>
                <li>How can you ensure you're not using the same element twice?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create a hash map to store values and their indices
2. First pass: Populate the hash map with all numbers and their indices
3. Second pass: For each number in the array:
   a. Calculate the complement (target - current number)
   b. Check if the complement exists in the hash map
   c. Make sure the complement isn't the same index as the current number
   d. If found, return the indices of the current number and its complement</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        indices = {}  # val -> index

        for i, n in enumerate(nums):
            indices[n] = i

        for i, n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "HASH MAP",
            codeExplanation: "This code finds a pair of numbers in an array that add up to a specific target value. It uses a two-pass approach: first storing all values and their indices in a hash map, then checking for each number if its complement (target - number) exists in the map. The check ensures we don't use the same array element twice by comparing indices.",
            mnemonicsContent: `
              <ul>
                <li><strong>Matching Pairs Game:</strong> For each number, you're looking for its perfect match (complement) that sums to the target.</li>
                <li><strong>Complement Finding:</strong> For each number, find its complement (target - number
                mnemonicsContent: `
              <ul>
                <li><strong>Matching Pairs Game:</strong> For each number, you're looking for its perfect match (complement) that sums to the target.</li>
                <li><strong>Complement Finding:</strong> For each number, find its complement (target - number).</li>
                <li><strong>Two-Pass Approach:</strong> First store all numbers in a hash map, then look for complements.</li>
                <li><strong>Key-Value Strategy:</strong> Store values as keys and indices as values for quick lookup.</li>
                <li><strong>Same Index Check:</strong> Remember to check that you're not using the same array element twice.</li>
              </ul>
            `
          },
          {
            id: 4,
            title: "Group Anagrams",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Group Anagrams</div>
              <p>Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.</p>
              <p>An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: strs = ["act","pots","tops","cat","stop","hat"]
Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Group Anagrams</div>
              <ul>
                <li>How can you identify that two strings are anagrams of each other?</li>
                <li>Consider using a hash map to group strings</li>
                <li>What could be used as a key to identify all anagrams of the same group?</li>
                <li>Would sorting the characters of each string help?</li>
                <li>Can you use character counts instead of sorting?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create a hash map to group anagrams (key: character count, value: list of strings)
2. For each string in the input array:
   a. Create a count array of size 26 for lowercase letters
   b. Count the frequency of each character in the string
   c. Convert the count array to a tuple to use as a key
   d. Add the string to the list of strings for this key
3. Return all the grouped lists of anagrams</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(m*n)</span>
                <span class="complexity space">Space: O(m)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            res[tuple(count)].append(s)
        return list(res.values())</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(m*n)</span>
                <span class="complexity space">Space: O(m)</span>
              </div>
            `,
            method: "HASH TABLE",
            codeExplanation: "This code groups strings that are anagrams of each other. For each string, it creates a 'fingerprint' by counting the frequency of each character (using a 26-element array for a-z). It uses this fingerprint (converted to a tuple to make it hashable) as a key in a dictionary, with the values being lists of strings that share the same fingerprint. The defaultdict ensures new keys automatically create an empty list.",
            mnemonicsContent: `
              <ul>
                <li><strong>DNA Fingerprinting:</strong> Each word gets a unique 'fingerprint' based on its character counts, and words with matching fingerprints are grouped together.</li>
                <li><strong>Anagram Identifier:</strong> Character counts uniquely identify anagrams.</li>
                <li><strong>Frequency Fingerprint:</strong> Use a 26-element array as a "fingerprint" for each word.</li>
                <li><strong>Tuple as Key:</strong> Lists aren't hashable, so convert to tuple for dictionary keys.</li>
                <li><strong>Group by Key:</strong> Words with identical character counts get grouped together.</li>
              </ul>
            `
          },
          {
            id: 5,
            title: "Top K Frequent Elements",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Top K Frequent Elements</div>
              <p>Given an integer array nums and an integer k, return the k most frequent elements within the array.</p>
              <p>The test cases are generated such that the answer is always unique.</p>
              <p>You may return the output in any order.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [1,2,2,3,3,3], k = 2
Output: [2,3]</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Top K Frequent Elements</div>
              <ul>
                <li>How can you count the frequency of each element?</li>
                <li>After counting, how do you find the top k?</li>
                <li>Consider using a bucket sort approach</li>
                <li>What data structure can map numbers to their frequencies?</li>
                <li>Can you avoid using a sorting algorithm?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Count the frequency of each number using a hash map
2. Create buckets (lists) for each possible frequency (0 to n)
3. Place numbers in their frequency bucket
4. Start from the highest frequency bucket and collect numbers
5. Return once k numbers have been collected</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)]

        for num in nums:
            count[num] = 1 + count.get(num, 0)
        for num, cnt in count.items():
            freq[cnt].append(num)
        
        res = []
        for i in range(len(freq) - 1, 0, -1):
            for num in freq[i]:
                res.append(num)
                if len(res) == k:
                    return res</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "BUCKET SORT",
            codeExplanation: "This code finds the k most frequent elements in an array. First, it counts the frequency of each number using a hash map. Then, it uses a bucket sort approach by creating an array of lists where the index represents frequency. Each number is placed in its corresponding frequency bucket. Finally, it collects the numbers starting from the highest frequency bucket until it has k elements.",
            mnemonicsContent: `
              <ul>
                <li><strong>Popularity Contest:</strong> Think of it like sorting celebrities by their number of followers, from most to least popular.</li>
                <li><strong>Count First:</strong> Always start by counting frequencies with a hash map.</li>
                <li><strong>Bucket Organization:</strong> Create buckets where the index is the frequency.</li>
                <li><strong>Reverse Traversal:</strong> Start from highest frequency bucket to find top elements.</li>
                <li><strong>Linear Time:</strong> Bucket sort achieves O(n) time without comparison-based sorting.</li>
              </ul>
            `
          },
          {
            id: 6,
            title: "Encode and Decode Strings",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Encode and Decode Strings</div>
              <p>Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.</p>
              <p>Please implement encode and decode</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: ["neet","code","love","you"]
Output:["neet","code","love","you"]</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Encode and Decode Strings</div>
              <ul>
                <li>How can you separate strings so you can identify them later?</li>
                <li>Consider using a delimiter, but be careful about strings containing the delimiter</li>
                <li>What if you include the length of each string before the string itself?</li>
                <li>Think about a format like: [length]#[string]</li>
                <li>How will you parse the encoded string during decoding?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
Encode:
1. For each string in the list:
   a. Append the length of the string, followed by a delimiter (#)
   b. Append the string itself
2. Return the concatenated result

Decode:
1. Initialize an empty result list and a pointer i = 0
2. While i < length of encoded string:
   a. Find the delimiter (#) to get the length of the next string
   b. Extract the length value
   c. Extract the string using the length
   d. Add the string to result list
   e. Move pointer i to the next position
3. Return the result list</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res = []
        i = 0
        
        while i < len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            i = j + 1
            j = i + length
            res.append(s[i:j])
            i = j
            
        return res</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "LENGTH PREFIX",
            codeExplanation: "This code implements a method to encode a list of strings into a single string and decode it back. The encoding prefixes each string with its length followed by a delimiter (#). For example, ['abc', 'def'] becomes '3#abc3#def'. The decoding process uses two pointers to parse this format: first finding the delimiter to extract the length, then using that length to extract the actual string.",
            mnemonicsContent: `
              <ul>
                <li><strong>Package Shipping Label:</strong> Think of each string as a package, and you're adding a shipping label with its exact size (length#) before sending it.</li>
                <li><strong>Length + Delimiter:</strong> Encode using format "length#string".</li>
                <li><strong>Two-Pointer Extraction:</strong> Use two pointers to parse the encoded string.</li>
                <li><strong>Find-Parse-Extract:</strong> Find the delimiter, parse the length, extract the substring.</li>
                <li><strong>Sequential Reading:</strong> Decode by reading one string at a time, moving forward.</li>
              </ul>
            `
          },
          {
            id: 7,
            title: "Product of Array Except Self",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Product of Array Except Self</div>
              <p>Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].</p>
              <p>Each product is guaranteed to fit in a 32-bit integer.</p>
              <p>Follow-up: Could you solve it in O(n) time without using the division operation?</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [1,2,4,6]
Output: [48,24,12,8]</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Product of Array Except Self</div>
              <ul>
                <li>Consider the product of all numbers to the left of each index</li>
                <li>Consider the product of all numbers to the right of each index</li>
                <li>Can you use prefix and suffix products?</li>
                <li>How can you avoid using extra space?</li>
                <li>Try using the output array to store intermediate results</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create a result array filled with 1s (same size as input)
2. Calculate prefix products:
   a. Initialize a variable to track the running product = 1
   b. Iterate from left to right
   c. Store the current prefix product in the result array
   d. Update the running product by multiplying with the current input value
3. Calculate suffix products and multiply with prefix products:
   a. Initialize a variable to track the running product = 1
   b. Iterate from right to left
   c. Multiply the current result value by the suffix product
   d. Update the running product by multiplying with the current input value
4. Return the result array</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            method: "PREFIX & SUFFIX",
            codeExplanation: "This elegant code calculates the product of all elements in an array except for the element at each position, without using division. It uses a two-pass approach: First, it builds prefix products (product of all elements to the left) for each position. Then it goes backward, multiplying each position by the running product of all elements to the right (suffix product). The final result contains prefix * suffix for each position.",
            mnemonicsContent: `
              <ul>
                <li><strong>Left Hand × Right Hand:</strong> Think of cupping your hands around each number - the left hand holds the product of everything to the left, the right hand holds the product of everything to the right.</li>
                <li><strong>Two-Pass Approach:</strong> First calculate prefix products, then suffix products.</li>
                <li><strong>Running Product:</strong> Maintain a running product as you iterate through the array.</li>
                <li><strong>Output Array Reuse:</strong> Use the output array to store intermediate results (prefix products).</li>
                <li><strong>Multiplication Splitting:</strong> The product of all except self = (product of all before) * (product of all after).</li>
              </ul>
            `
          },
          {
            id: 8,
            title: "Valid Sudoku",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Valid Sudoku</div>
              <p>You are given a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:</p>
              <ul>
                <li>Each row must contain the digits 1-9 without duplicates.</li>
                <li>Each column must contain the digits 1-9 without duplicates.</li>
                <li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.</li>
              </ul>
              <p>Return true if the Sudoku board is valid, otherwise return false.</p>
              <p>Note: A board does not need to be full or be solvable to be valid.</p>
              <br>
              <pre>
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Valid Sudoku</div>
              <ul>
                <li>Consider checking rows, columns, and 3x3 boxes separately</li>
                <li>How can you detect if a number appears more than once?</li>
                <li>Think about using sets to track seen numbers</li>
                <li>What's an efficient way to map a cell to its 3x3 box?</li>
                <li>Remember to skip empty cells ('.')</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Check each row:
   a. For each row, create a set to track seen digits
   b. Iterate through each cell in the row
   c. Skip empty cells
   d. If a digit is already in the set, return False
   e. Otherwise, add the digit to the set
2. Check each column (similar to rows)
3. Check each 3x3 box:
   a. For each of the 9 boxes, create a set
   b. Map each cell to its corresponding box
   c. Skip empty cells
   d. Check for duplicates using the set
4. If all checks pass, return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n²)</span>
                <span class="complexity space">Space: O(n²)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in range(9):
            seen = set()
            for i in range(9):
                if board[row][i] == ".": 
                    continue
                if board[row][i] in seen:
                    return False
                seen.add(board[row][i])
        
        for col in range(9):
            seen = set()
            for i in range(9):
                if board[i][col] == ".":
                    continue
                if board[i][col] in seen:
                    return False
                seen.add(board[i][col])
            
        for square in range(9):
            seen = set()
            for i in range(3):
                for j in range(3):
                    row = (square//3) * 3 + i
                    col = (square % 3) * 3 + j
                    if board[row][col] == ".":
                        continue
                    if board[row][col] in seen:
                        return False
                    seen.add(board[row][col])
        return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n²)</span>
                <span class="complexity space">Space: O(n²)</span>
              </div>
            `,
            method: "HASH SET",
            codeExplanation: "This code validates a Sudoku board by checking the three rules: no duplicates in any row, any column, or any 3×3 box. It uses sets to track seen digits in each group. For the 3×3 boxes, it uses a clever mapping formula: (square//3)*3 + i for row, (square%3)*3 + j for column. Empty cells ('.') are skipped. If any duplicate is found, it returns False immediately.",
            mnemonicsContent: `
              <ul>
                <li><strong>Triple Validation Check:</strong> Think of it as three security guards checking the same person's ID in different ways - row check, column check, and box check.</li>
                <li><strong>Three Separate Checks:</strong> Validate rows, columns, and 3x3 boxes independently.</li>
                <li><strong>Set-Based Validation:</strong> Use hash sets to detect duplicates in each group.</li>
                <li><strong>Box Indexing Formula:</strong> (square//3)*3 + i for row, (square%3)*3 + j for column.</li>
                <li><strong>Empty Cell Skipping:</strong> Always skip cells containing "." before checking.</li>
              </ul>
            `
          },
          {
            id: 9,
            title: "Longest Consecutive Sequence",
            category: "Arrays & Hashing",
            questionContent: `
              <div class="card-title">Longest Consecutive Sequence</div>
              <p>Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.</p>
              <p>A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.</p>
              <p>You must write an algorithm that runs in O(n) time.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: nums = [2,20,4,10,3,4,5]
Output: 4</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Longest Consecutive Sequence</div>
              <ul>
                <li>How can you efficiently find if a number is part of a sequence?</li>
                <li>Consider using a set for O(1) lookups</li>
                <li>When should you start counting a sequence?</li>
                <li>Is there a way to avoid duplicate work?</li>
                <li>Think about finding the start of each sequence</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Create a set from the input array for O(1) lookups
2. Initialize a variable to track the longest sequence found
3. For each number in the set:
   a. Check if it's the start of a sequence (num-1 is not in the set)
   b. If it's a start, count consecutive numbers (num+1, num+2, etc.)
   c. Update the longest sequence if the current one is longer
4. Return the length of the longest sequence found</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(n)</span>
              </div>
            `,
            method: "HASH SET",
            codeExplanation: "This code finds the length of the longest consecutive sequence in an array. It first converts the array to a set for O(1) lookups. Then it looks for potential sequence starts (numbers that don't have their predecessor in the set). For each potential start, it counts forward to find the sequence length. This approach is clever because it only does the counting work for actual sequence starts, avoiding duplicate work.",
            mnemonicsContent: `
              <ul>
                <li><strong>Chain Link Counting:</strong> Think of finding the head of each chain (sequence start) and then measuring how long each chain is by counting links one by one.</li>
                <li><strong>Find Sequence Starts:</strong> Only check numbers that could be the start of a sequence.</li>
                <li><strong>Efficient Lookups:</strong> Use a hash set for O(1) membership tests.</li>
                <li><strong>Linear Scanning:</strong> Once a start is found, iterate forward to find sequence length.</li>
                <li><strong>Avoid Duplicate Work:</strong> Skip numbers that can't be sequence starts.</li>
              </ul>
            `
          },
          {
            id: 10,
            title: "Valid Palindrome",
            category: "Two Pointers",
            questionContent: `
              <div class="card-title">Valid Palindrome</div>
              <p>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.</p>
              <p>Given a string s, return true if it is a palindrome, otherwise return false.</p>
              <br>
              <p><strong>Example 1:</strong></p>
              <pre>
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.</pre>
            `,
            hintContent: `
              <div class="card-title">Hints for Valid Palindrome</div>
              <ul>
                <li>How do you handle uppercase and lowercase characters?</li>
                <li>What characters should you ignore?</li>
                <li>Can you use two pointers to check from both ends?</li>
                <li>Consider how to efficiently compare characters without creating a new string</li>
                <li>What are the edge cases to handle?</li>
              </ul>
            `,
            blueprintContent: `
              <div class="card-title">Solution Blueprint</div>
              <pre>
1. Initialize two pointers, left at the beginning and right at the end
2. While left < right:
   a. Skip non-alphanumeric characters from left
   b. Skip non-alphanumeric characters from right
   c. Compare characters at left and right (case-insensitive)
   d. If they don't match, return False
   e. Move left forward and right backward
3. If the loop completes, return True</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            codeContent: `
              <div class="card-title">Optimized Implementation</div>
              <pre>
class Solution:
    def isPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1
        
        while l < r:
            while l < r and not self.isAlphaNum(s[l]):
                l += 1
            while l < r and not self.isAlphaNum(s[r]):
                r -= 1
                
            if s[l].lower() != s[r].lower():
                return False
                
            l += 1
            r -= 1
        return True
    
    def isAlphaNum(self, c: str) -> bool:
        return (ord('A') <= ord(c) <= ord('Z') or
                ord('a') <= ord(c) <= ord('z') or
                ord('0') <= ord(c) <= ord('9'))</pre>
              <div style="margin-top: 20px;">
                <span class="complexity time">Time: O(n)</span>
                <span class="complexity space">Space: O(1)</span>
              </div>
            `,
            method: "TWO POINTERS",
            codeExplanation: "This code checks if a string is a palindrome after removing non-alphanumeric characters and ignoring case. It uses a two-pointer approach: one pointer starts at the beginning, the other at the end. Both pointers move inward, skipping non-alphanumeric characters and comparing the valid characters. If any comparison fails, the string is not a palindrome. The helper function isAlphaNum determines if a character is a letter or digit using ASCII values.",
            mnemonicsContent: `
              <ul>
                <li><strong>Mirror Reading:</strong> Imagine two people starting at opposite ends of a sentence, reading toward each other, skipping punctuation, and comparing what they read.</li>
                <li><strong>Skip and Compare:</strong> Skip irrelevant characters, compare valid ones.</li>
                <li><strong>Outside-In Approach:</strong> Check from both ends moving inward.</li>
                <li><strong>Case Insensitivity:</strong> Convert to lowercase before comparing.</li>
                <li><strong>In-place Checking:</strong> No need for extra string - check the original directly.</li>
              </ul>
            `
          }
        ];

        // Debug message
        console.log("Cards data loaded successfully with " + cardsData.length + " cards");
    </script>
    
    <script>
        // Score tracking system
        const ScoreTracker = {
          // Initialize the score tracking system
          init: function() {
            // Initialize if no score data exists
            if (!localStorage.getItem('leetcodeScores')) {
              this.resetScores();
            }
            
            // Check if we need to reset weekly scores (new week)
            this.checkWeeklyReset();
            
            // Display current score
            this.updateScoreDisplay();
          },
          
          // Add points to user's score
          addPoints: function(points) {
            const scores = this.getScores();
            scores.weekly += points;
            scores.allTime += points;
            scores.lastUpdated = new Date().getTime();
            
            // Save updated scores
            localStorage.setItem('leetcodeScores', JSON.stringify(scores));
            
            // Update the display
            this.updateScoreDisplay();
            
            // Show animation for points gained
            this.showPointsAnimation(points);
          },
          
          // Get current scores
          getScores: function() {
            return JSON.parse(localStorage.getItem('leetcodeScores'));
          },
          
          // Reset all score data
          resetScores: function() {
            const scoreData = {
              weekly: 0,
              allTime: 0,
              weekStartDate: this.getStartOfWeek(),
              lastUpdated: new Date().getTime()
            };
            localStorage.setItem('leetcodeScores', JSON.stringify(scoreData));
          },
          
          // Reset just the weekly score
          resetWeeklyScore: function() {
            const scores = this.getScores();
            scores.weekly = 0;
            scores.weekStartDate = this.getStartOfWeek();
            localStorage.setItem('leetcodeScores', JSON.stringify(scores));
          },
          
          // Check if we need to reset weekly scores
          checkWeeklyReset: function() {
            const scores = this.getScores();
            const currentWeekStart = this.getStartOfWeek();
            
            // If we're in a new week, reset weekly score
            if (scores.weekStartDate < currentWeekStart) {
              this.resetWeeklyScore();
            }
          },
          
          // Get timestamp for start of current week (Sunday midnight)
          getStartOfWeek: function() {
            const now = new Date();
            const dayOfWeek = now.getDay(); // 0 = Sunday
            const diff = now.getDate() - dayOfWeek;
            const startOfWeek = new Date(now.setDate(diff));
            startOfWeek.setHours(0, 0, 0, 0);
            return startOfWeek.getTime();
          },
          
          // Update the score display in the UI
          updateScoreDisplay: function() {
            const scores = this.getScores();
            const scoreDisplay = document.getElementById('score-display');
            
            if (scoreDisplay) {
              scoreDisplay.textContent = `Weekly Score: ${scores.weekly}`;
              
              // Add visual cue for high scores
              if (scores.weekly > 50) {
                scoreDisplay.classList.add('high-score');
              } else {
                scoreDisplay.classList.remove('high-score');
              }
            }
          },
          
          // Show animation when points are earned
          showPointsAnimation: function(points) {
            // Create animation element
            const animation = document.createElement('div');
            animation.className = 'points-animation';
            animation.textContent = `+${points}`;
            
            // Add to the DOM
            document.body.appendChild(animation);
            
            // Trigger animation and remove after it completes
            setTimeout(() => {
              animation.classList.add('animate');
              setTimeout(() => {
                document.body.removeChild(animation);
              }, 1000);
            }, 10);
          }
        };

        // Add URL parameter handling to load specific cards
        function getCardFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const cardId = urlParams.get('card');
            if (cardId) {
                // Find the card index by ID
                for (let i = 0; i < cardsData.length; i++) {
                    if (cardsData[i].id.toString() === cardId) {
                        return i;
                    }
                }
            }
            return 0; // Default to first card if not found
        }

        // Share button functionality
        function setupShareButton() {
            const shareButton = document.getElementById('share-button');
            if (!shareButton) return;
            
            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'share-tooltip';
            tooltip.innerHTML = `
                <p>Share this card:</p>
                <input type="text" id="share-url" readonly style="width: 100%; margin-top: 5px;">
                <button class="copy-button" id="copy-button">Copy Link</button>
            `;
            shareButton.appendChild(tooltip);
            
            // Toggle tooltip on share button click
            shareButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip
                tooltip.classList.toggle('active');
                
                if (tooltip.classList.contains('active')) {
                    // Generate share URL with current card ID
                    const currentCard = cardsData[currentCardIndex];
                    const shareUrl = `${window.location.origin}${window.location.pathname}?card=${currentCard.id}`;
                    document.getElementById('share-url').value = shareUrl;
                }
            });
            
            // Copy link button functionality
            document.getElementById('copy-button').addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip
                const shareUrl = document.getElementById('share-url');
                shareUrl.select();
                document.execCommand('copy');
                
                // Show feedback
                this.textContent = 'Copied!';
                setTimeout(() => {
                    this.textContent = 'Copy Link';
                    tooltip.classList.remove('active');
                }, 1500);
            });
            
            // Hide tooltip when clicking elsewhere
            document.addEventListener('click', function(e) {
                if (!shareButton.contains(e.target)) {
                    tooltip.classList.remove('active');
                }
            });
        }
        
        // Global variable to track current card
        let currentCardIndex = 0;
        
        // Function to update the card content
        function updateCardContent() {
            console.log("Updating card to index:", currentCardIndex);
            
            // Make sure cardsData is available
            if (!cardsData || !cardsData.length) {
                console.error("Card data not found!");
                return;
            }
            
            const card = cardsData[currentCardIndex];
            console.log("Current card:", card.title);
            
            // Update category badge
            document.getElementById('category-badge').textContent = card.category || "Unknown";
            
            // Update tab contents
            document.getElementById('question').innerHTML = card.questionContent || "Question content missing";
            document.getElementById('hint').innerHTML = card.hintContent || "Hint content missing";
            document.getElementById('blueprint').innerHTML = card.blueprintContent || "Blueprint content missing";
            document.getElementById('code').innerHTML = card.codeContent || "Code content missing";
            
            // Update back side with explanation and solution code
            document.getElementById('method-badge').textContent = card.method || "METHOD";
            document.getElementById('code-explanation').innerHTML = card.codeExplanation || "No explanation available for this code.";
            document.getElementById('mnemonics').innerHTML = card.mnemonicsContent || "No memory aids available.";
            
            // Extract the actual code from the codeContent HTML
            let codeBlock = document.createElement('div');
            codeBlock.innerHTML = card.codeContent;
            
            // Find the <pre> tag containing the actual code
            let preElement = codeBlock.querySelector('pre');
            let actualCode = preElement ? preElement.textContent : "Code not available";
            
            // Update the solution code on the back side
            document.getElementById('solution-code').textContent = actualCode;
            
            // Update navigation
            document.getElementById('current-card').textContent = currentCardIndex + 1;
            document.getElementById('total-cards').textContent = cardsData.length;
            
            // Update navigation buttons
            document.getElementById('prev-button').disabled = currentCardIndex === 0;
            document.getElementById('next-button').disabled = currentCardIndex === cardsData.length - 1;
        }
        
        // Card flip functionality
        document.querySelector('.flashcard').addEventListener('click', function(e) {
            // Don't flip if clicking on tabs or share button
            if (!e.target.classList.contains('tab') && 
                !e.target.closest('#share-button') && 
                !e.target.closest('#answer-button')) {
                this.classList.toggle('is-flipped');
            }
        });
        
        // Tab switching functionality
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card flip when clicking on tabs
                
                // Remove active class from all tabs and tab contents
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab
                this.classList.add('active');
                
                // Show corresponding tab content
                const tabId = this.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });
        
        // Navigation buttons
        document.getElementById('prev-button').addEventListener('click', function() {
            console.log("Prev button clicked, current index:", currentCardIndex);
            if (currentCardIndex > 0) {
                currentCardIndex--;
                updateCardContent();
                // Ensure card is showing front side when navigating
                document.querySelector('.flashcard').classList.remove('is-flipped');
            }
        });
        
        document.getElementById('next-button').addEventListener('click', function() {
            console.log("Next button clicked, current index:", currentCardIndex);
            if (currentCardIndex < cardsData.length - 1) {
                currentCardIndex++;
                updateCardContent();
                // Ensure card is showing front side when navigating
                document.querySelector('.flashcard').classList.remove('is-flipped');
            }
        });
        
        // Theme switching functionality
        const themeButtons = document.querySelectorAll('.theme-btn');
        themeButtons.forEach(button => {
            button.addEventListener('click', function() {
                const body = document.body;
                
                // Remove all theme classes
                body.classList.remove('light-theme', 'dark-theme', 'blue-theme');
                
                // Add selected theme class
                if (this.classList.contains('light-btn')) {
                    body.classList.add('light-theme');
                } else if (this.classList.contains('dark-btn')) {
                    body.classList.add('dark-theme');
                } else if (this.classList.contains('blue-btn')) {
                    body.classList.add('blue-theme');
                }
            });
        });
        
        // Answer button for quiz mode
        document.getElementById('answer-button').addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent card flip
            
            // Award points
            ScoreTracker.addPoints(10);
            
            // Provide feedback
            this.textContent = "Great job! +10 points";
            this.disabled = true;
            
            setTimeout(() => {
                this.textContent = "I Know The Answer (+10 points)";
                this.disabled = false;
            }, 2000);
        });
        
        // Initialize when the document is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing app");
            
            // Set current card index based on URL parameter
            currentCardIndex = getCardFromURL();
            
            // Initialize score tracking
            ScoreTracker.init();
            
            // Update card content and setup share functionality
            updateCardContent();
            setupShareButton();
        });

        // Also try to initialize immediately in case DOMContentLoaded already fired
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            console.log("Document already loaded, initializing now");
            setTimeout(function() {
                // Set current card index based on URL parameter
                currentCardIndex = getCardFromURL();
                
                // Initialize score tracking
                ScoreTracker.init();
                
                // Update card content and setup share functionality
                updateCardContent();
                setupShareButton();
            }, 100);
        }
    </script>
</body>
</html>
